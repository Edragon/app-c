#include <STC12C2052AD.H> 	//单片机头文件
#include <intrins.h> 		//51基本运算（包括_nop_空函数）
#define uchar unsigned char
#define uint unsigned int

sbit temp=P1^7;
sbit LED3=P3^0;  //C
sbit LED0=P1^4;  //	小数点后一位
sbit LED1=P1^3;  //个位
sbit LED2=P1^0;  //	十位
sbit A=P1^1;
sbit B_B=P1^5;
sbit C=P3^2;
sbit D=P3^4;
sbit E=P3^5;
sbit F=P1^2;
sbit G=P3^1;
sbit H=P3^3;  //小数点

char d[5];
uint R,M,N,h;//若定义成uchar型就只能显示2.5V以下的数值

void dm(mz);

void delayus(uint x)	 //(x+1)*6微
{

	while(x--);
}


/*****************************************************************
函数名：毫秒级CPU延时函数
调  用：delay (?);
参  数：1-65535（参数不可为0）
返回值：无
结  果：占用CPU方式延时与参数数值相同的毫秒时间
备  注：应用于1T单片机时i<600，应用于12T单片机时i<125
/******************************************************************/
void delay(uint t)
{
uint i;               		//定义变量
for(;t>0;t--)             	//如果t大于0，t减1（外层循环）
  for(i=600;i>0;i--);       //i等于124，如果i大于0，i减1
}
/*******************************************************************
函数名：ADC初始化及8位A/D转换函数
返回值：8位的ADC数据
结  果：读出指定ADC接口的A/D转换值，并返回数值
备  注：适用于STC12C2052AD系列单片机（必须使用STC12C2052AD.h头文件）
*******************************************************************/
uchar Read (uchar CHA)
{
	uchar AD_FIN=0; 		//存储A/D转换标志;若在函数外定义此变量则不能得到连续变化的模拟量的显示
	/******以下为ADC初始化程序****************************/
    CHA &= 0x07;            //选择ADC的8个接口中的一个（0000 0111 清0高5位）
    ADC_CONTR = 0x60;  		//ADC转换的速度（0XX0 0000 其中XX控制速度，请根据数据手册设置）
    _nop_();
    ADC_CONTR |= CHA;       //选择A/D当前通道
    _nop_();
    ADC_CONTR |= 0x80;     	//启动A/D电源
    delay(1);            	//使输入电压达到稳定（1ms即可?
	/******以下为ADC执行程序****************************/
    ADC_CONTR |= 0x08;      //启动A/D转换（0000 1000 令ADCS = 1）
    _nop_();
    _nop_();
    _nop_();
    _nop_();
    while (AD_FIN ==0)	   //等待A/D转换结束
	{     
    	AD_FIN = (ADC_CONTR & 0x10); 	//0001 0000测试A/D转换结束否
    }
    ADC_CONTR &= 0xE7;      			//1111 0111 清ADC_FLAG位, 关闭A/D转换,
	return (ADC_DATA);          		//返回A/D转换结果（8位）
}
/******************************************************************
显示函数转换函数：
M=模拟量采样值，N=基准电压源采样值（本例为2.5V），R=模拟量输入值（待显示值）
N=256*2.5/Vcc；变形后得Vcc=256*2.5/N； 代入M=256*R/Vcc；得到M=R*N/2.5；变形后得R=M*2.5/N
1.105为输入端分压比。
******************************************************************/
void transfer(void)
{
	M=Read(6);				//P1.6口模拟量转换
	N=Read(7);				//P1.7口2.5V基准电压源采样（转换）
	R=((M*2.5)/N)*198;		//输入模拟量换算并放大500倍；
	/***以下为3位显示转换***/
	h=R;
	d[3]=R/1000;
	R=R%1000;
	d[2]=R/100;
	R=R%100;
	d[1]=R/10;
	d[0]=R%10;

}
/**********显示函数（未优化）************************************************/
void xian_shi (void)
{
	if(h>999)
	{
		d[3]=10;
		d[2]=10;
		d[1]=10;
		d[0]=10;
	}
	if(d[3]==0)	
	d[3]=11;
	dm(d[3]);
	LED3=1;
	delayus(5);
	LED3=0;
	delayus(30);
	dm(d[2]);
	LED2=1;
	delayus(5);
	LED2=0;
	delayus(30);
	dm(12);
	LED2=1;
	delayus(1);
	LED2=0;
	delayus(400);
	dm(d[1]);
	LED1=1;
	delayus(5);
	LED1=0;
	delayus(30);
	dm(d[0]);
	LED0=1;
	delayus(5);
	LED0=0;
	delayus(30);
}


void dm(mz)
{
	switch(mz)
	{
		case 0:A=0;B_B=0;C=0;D=0;E=0;F=0;G=1;H=1;break;
		case 1:A=1;B_B=0;C=0;D=1;E=1;F=1;G=1;H=1;break;
		case 2:A=0;B_B=0;C=1;D=0;E=0;F=1;G=0;H=1;break;
		case 3:A=0;B_B=0;C=0;D=0;E=1;F=1;G=0;H=1;break;
		case 4:A=1;B_B=0;C=0;D=1;E=1;F=0;G=0;H=1;break;
		case 5:A=0;B_B=1;C=0;D=0;E=1;F=0;G=0;H=1;break;
		case 6:A=0;B_B=1;C=0;D=0;E=0;F=0;G=0;H=1;break;
		case 7:A=0;B_B=0;C=0;D=1;E=1;F=1;G=1;H=1;break;
		case 8:A=0;B_B=0;C=0;D=0;E=0;F=0;G=0;H=1;break;
		case 9:A=0;B_B=0;C=0;D=0;E=1;F=0;G=0;H=1;break;
		case 10:A=0;B_B=1;C=1;D=0;E=0;F=0;G=1;H=1;break; //C
		case 11:A=1;B_B=1;C=1;D=1;E=1;F=1;G=1;H=1;break; //不显示
		case 12:A=1;B_B=1;C=1;D=1;E=1;F=1;G=1;H=0;break; //小数点
	}
}


/******************************************************************
函数名：主函数
调  用：无
参  数：无
返回值：无
结  果：程序开始处，无限循环
备  注：
******************************************************************/
void main (void)
{
    P1M0 = 0xC0;                
    P1M1 = 0x19;   
    P3M0=0x00;
    P3M1=0x01;
 	LED0=0; 
	LED1=0; 
	LED2=0;  
	LED3=0;  

	while(1)
	{
		uint i;
		i++;
		if (i==500)
		{
			transfer();
			i=0;
		}
		xian_shi();
	}
} 